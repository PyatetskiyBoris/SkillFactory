import numpy as np


def score_game(game_core):
    """Запускаем игру 1000 раз, чтобы узнать, как быстро игра угадывает число"""
    count_ls = []
    np.random.seed(1)  # фиксируем RANDOM SEED, чтобы ваш эксперимент был воспроизводим!
    random_array = np.random.randint(1, 101, size=1000)
    for number in random_array:
        count_ls.append(game_core(number))
    score = int(np.mean(count_ls))
    print(f"Ваш алгоритм {game_core} угадывает число в среднем за {score} попыток")
    return score


def game_core_v3(number):
    """Усовершенствование алгоритма из задания. Алгоритм, схожий с алгоритмом бинарного поиска,
       но вместо числа посередине диапазона использует случайное число из этого диапазона.
       Случайное число сравнивается с загаданным, и диапазон выбора дальнейшего случайного числа
       сужается в зависимости от результата.
       Функция принимает загаданное число и возвращает число попыток"""
    count = 0         # Счётчик попыток
    min_number = 1    # Минимальное число диапазона, где может находится загаданное число
    max_number = 100  # Максимальное число диапазона, где может находится загаданное число
    predict = 0       # Число, которое мы "называем", спрашивая, больше оно или меньше загаданного

    while number != predict:
        predict = np.random.randint(min_number, max_number)   # "Называем" случайное число из диапазона
        count += 1
        # Если "названное" число меньше загаданного, увеличиваем минимальное возможное число диапазона
        if number > predict:
            min_number = predict + 1
        # Если "названное" число больше загаданного, уменьшаем максимальное возможное число диапазона
        elif number < predict:
            max_number = predict - 1

        # Когда диапазон сужается до одного числа, заявляем, что мы угадали число
        # и "называем" его, засчитывая это за последнюю попытку
        if max_number == min_number:
            predict = max_number
            count += 1
    return count  # выход из цикла, если угадали


# Проверяем, сколько в среднем попыток нужно алгоритму, чтобы угадать число
score_game(game_core_v3)


def game_core_v4(number):
    """Дальнейшее усовершенствование алгоритма из задания. "Называем" случайное число и в зависимости от результата
       одновременно уменьшаем максимальное число диапазона и увеличиваем минимальное. Если угаданное число выпало
       из диапазона, то изменяем диапазон.
       Это, наверное, читерство, потому что мы сравниваем с загаданным числом не само случайное, а диапазон случайного
       числа и только потом само случайное.
       Функция принимает загаданное число и возвращает число попыток"""
    count = 0           # Счётчик попыток
    min_number = 1      # Минимальное число диапазона, где может находится загаданное число
    max_number = 100    # Максимальное число диапазона, где может находится загаданное число
    predict = 0         # Число, которое мы "называем", спрашивая, больше оно или меньше загаданного

    while number != predict:
        predict = np.random.randint(min_number, max_number)    # "Называем" случайное число из диапазона
        count += 1
        # Если в диапазоне осталось только два числа, применяем алгоритм из game_core_v3
        if max_number - min_number < 2:
            if number > predict:
                min_number = predict + 1
            elif number < predict:
                max_number = predict - 1

        # Основной алгоритм для быстрого сужения диапазона
        else:
            max_prev = max_number    # Сохраняем предыдущее значения максимума диапазона
            min_prev = min_number    # Сохраняем предыдущее значения минимума диапазона

            # Если "названное" число меньше загаданного, новое минимальное число диапазона ограничиваем "названным",
            # а новое максимальное - средним между названным и предыдущим максимумом
            if number > predict:
                min_number = predict + 1
                max_number = round((predict + max_number) / 2)

                # Если загаданное число больше нового максимума, начинаем искать
                # в диапазоне между новым и старым максимумом.
                # На всякий случай увеличиваем количество попыток, чтобы было меньше похоже на читерство.
                if max_number < number:
                    min_number = max_number
                    max_number = max_prev
                    count += 1

            # Если "названное" число больше загаданного, новое максимально число диапазона ограничиваем "названным",
            # а новое минимальное - средним между названным и предыдущим минимумом
            elif number < predict:
                max_number = predict - 1
                min_number = round((predict + min_number) // 2)

                # Если загаданное число меньше нового минимума, начинаем искать
                # в диапазоне между старым и новым минимумом.
                # На всякий случай увеличиваем количество попыток, чтобы было меньше похоже на читерство.
                if min_number > number:
                    max_number = min_number
                    min_number = min_prev
                    count += 1

        # Когда диапазон сужается до одного числа, заявляем, что мы угадали число
        # и "называем" его, засчитывая это за последнюю попытку
        if max_number == min_number:
            predict = max_number
            count += 1
    return count  # выход из цикла, если угадали


# Проверяем, сколько в среднем попыток нужно алгоритму, чтобы угадать число
score_game(game_core_v4)


def game_core_v5(number):
    """Алгоритм бинарного поиска без использования случайных чисел. Делим пополам диапазон, в котором
       находится загаданное число, и спрашиваем, в какой половине оно находится, тем самым сужая диапазон.
       Функция принимает загаданное число и возвращает число попыток"""
    count = 0          # Счётчик попыток
    min_number = 0     # Минимальное число диапазона, где может находится загаданное число
    max_number = 100   # Максимальное число диапазона, где может находится загаданное число
    predict = 0        # Число, которое мы "называем", спрашивая, больше оно или меньше загаданного

    while number != predict:
        predict = round((min_number + max_number) / 2)  # "называем" число посередине диапазона
        count += 1
        # Если "названное" число меньше загаданного, увеличиваем минимальное возможное число диапазона
        if number > predict:
            min_number = predict
        # Если "названное" число больше загаданного, уменьшаем максимальное возможное число диапазона
        elif number < predict:
            max_number = predict

        # Когда диапазон сужается до одного числа, заявляем, что мы угадали число
        # и "называем" его, засчитывая это за последнюю попытку
        if max_number == min_number:
            predict = max_number
            count += 1
    return count  # выход из цикла, если угадали


# Проверяем, сколько в среднем попыток нужно алгоритму, чтобы угадать число
score_game(game_core_v5)


# Дополнительный блок для наглядности. Показывает, сколько нужно попыток каждому алгоритму,
# чтобы угадать все числа от 1 до 100
n_v3 = 0
n_v4 = 0
n_v5 = 0
for i in range(1, 101):
    n_v3 += game_core_v3(i)
    n_v4 += game_core_v4(i)
    n_v5 += game_core_v5(i)


print("Суммарное количество попыток для угадывания всех чисел от 1 до 100, алгоритм v3: ", n_v3)
print("Суммарное количество попыток для угадывания всех чисел от 1 до 100, алгоритм v4: ", n_v4)
print("Суммарное количество попыток для угадывания всех чисел от 1 до 100, алгоритм v5: ", n_v5)
